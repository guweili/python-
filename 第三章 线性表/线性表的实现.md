## 线性表的实现：基本考虑
下面研究表数据结构的实现问题，这里主要需要考虑两个方面的情况:
1. 计算机内存的特点，以及保存元素和元素顺序信息的需要。
2. 各种重要操作的效率。如果程序里需要一个表，其创建操作只执行了一次，但在其存在期间，可能反复的多次以各种方式使用，其中使用最频繁的操作通常包括表的性质判断函数is_empty等，还有访问，加入和删除元素，元素遍历等。在考虑表的实现结构时，需要特别考虑这些操作的实现效率。

另外，元素遍历就是一次访问表里的所有元素，操作效率与访问元素的个数有关。由于是遍历所有元素，自然希望完成整个的复杂都不超过0(n).下面可以看到，加入/删除访问元素的操作效率与表的实现结构有关。
基于个方面考虑，人们提出了两种基本的实现模型：
1. 将表中元素舒徐的存放在一大块连续的存储空间里，这样是实现的表也成为舒徐表。在这种实现中，元素间的顺序关系由它们存储顺序自然表示。
2. 将表元素存放在通过链接勾走起来的一系列存储块里，这样实现的表称为链接表，简称链表

### 顺序表的实现
顺序表的基本实现方式很简单： 表中元素顺序存放在一片足够大的连续存储区里，首元素存入存储区的开始位置，其余元素依次顺序存放。元素之间的逻辑顺序关系通过元素在存储区里的物理位置表示。

### 基本实现方式
1. 最常见情况是一个表里保存的元素类型相同，因此存储每个表怨怒是所需的存储量相同，可以在表里灯具安排同样大小的存储位置。这种安排可以直接映射到计算机内存和单元，表中任何元素位置的计算非常简单，存储操作可以在O(1)时间内完成。
2. 假设有一个顺序表对象，其元素村粗和在一片元素存储区，该存储区的起始位置一直为l0。假定表元素编号从0开始，元素e0自然应存储在内存位置Loc(e0) = l0。在假定表中一个元素所需要的存储单元数为c=size，在这种情况下，就有下面简单的元素ei的地址计算公式: Loc(ei) = Loc(e0) + c * i
3. 表元素的大小size通常可以静态确定(例如，元素是整数或实数，或包含一组大小去欸的那个的元素的复杂结构)，在这种情况下，计算机硬件将能支持高效的表元素访问。另一方面，如果表中元素的大小有可能不同，也不难处理，只要略微改变顺序表的存储结构，就任然可以保证0(1)时间的元素访问操作。
4. 顺序表元素存储区的基本表示方式，元素下标是其逻辑地址，可以用上面公式计算出其物理地址。根据前面有关计算机内存结构的讨论，元素访问是具有O(1)复杂度的操作。
5. 如果表元素的大小不同意，按照上面方案将元素的顺序存入元素存储区，将无法通过统一公式计算元素位置。这是可以采用另一种布局方案，将是继数据元素另行存储，在顺序表里各种单元位置保存对相应元素的应用信息。由于每个链接所需的存储量相同，通过上述统一公式，可以计算出元素链接的存储位置，而后顺链接做一次间接访问，就能等到实际元素的数据了。
6. 在确定了顺序表的基本表示方式之后，还需要进一步考虑线性表所需的各种操作特点和需求，以及由他们带来的结构性问题。
7. 线性表的一个重要性质是可以加入/删除元素，这也就是说，在一个表的存续期间，其长度可能变化。这就带来了一个问题：在建立一个表时，应该安排多大的一块存储区？表元素存储快需要安排在计算机内存里，一旦分配就占据了内存里的一块区域，有了固定的大小（并因此确定了容量，及确定了元素个数的上线）。而且，该块的前后都能呗其他有用对象占据，存储块的大小不能随便变化，特别是无法扩充。
8. 在建立一个顺序表时，一种可能是按照建立时确定怨怒是的个数分配存储。这种方式适合创建不变的顺序表，例如python的tuple对象。如果考虑的是变动的表，就必须区分表中的元素个数和元素存储区的容量。在建立这种表时，一个合理的办法是分配一块足以容纳当前需要记录的元素存储块，还应该保留一些空位，以满足增加元素的需要。
9. 这样，在一个舒徐表的元素存储里，一般情况是保存着一些元素，还存在一些可以存放元素的空位。在这中情况下，需要约定元素的存放方式，通常把已有元素连续存放在存储区前面一段，空位都在后面。为了保证正确操作，就许哟啊记录元素存储区的大小和当前的元素个数。这样一个顺序表对象的完整信息，这是一个具有可容纳8个元素的存储区，且当前存放了4个元素的顺序表

### 顺序表基本操作的实现
1. 有了表容量和元素个数信息，表操作的实现方式已经很清楚了。下面假设用max表示表的容量，即可能容纳的最大元素个数，num表示当前元素个数。
2. 创建和访问操作
   1. 创建空表：创建空表时，需要分配一块元素存储，记录表容量并将元素技术值设置为0。创建新表的存储后，应立即将两个表信息记录域 （max和num设置好），保证这个表处于合法状态。
   2. 简单判断操作：判断表空或表满的操作很容易实现，即表空当且仅当num=0，表满当且仅当num=max。这两个简单操作的复杂度都是0(1).
   3. 遍历操作：要顺序访问表中的元素，只需要在遍历过程中用一个整数变量记录遍历达到的位置。每次访问表元素时，通过存储区开始位置和上述变量的值在O(1)时间内可算出相应元素的位置 。完成元素访问（取元素值或修改元素值）。找下一元素的操作就是加1，找前一元素的操作就是减1，遍历中要保证下标加1减1后的访问不超出合法范围。
   4. 查找给定元素d的位置：这种操作称为检索或查找。在没有其他信息的情况下，只能通过用d与表中元素逐个比较的方式实现检索，成为线性检索。这里需要用一个基于下标的循环，每部用d与当前下标的表元素比较。下标变量控制循环的范围，从0开始至等于表中的元素个数时结束。再找到元素时返回元素下标，找不到时可以返回一个特殊值
   5. 查找给定元素d在位置k之后的第一次出现的位置：与上面操作的实现方式类似，只是需要从k+1位置的元素开始比较，而不是从位置0开始。
   6. 另一种需求与最后这两个操作类似：给定一个条件，要求找到第一个满足该条件的元素，或者某位置之后满足条件的下一个元素。条件可以是定义查找操作时确定的，更一般情况是允许在调用查找操作时提供一个描述条件的谓词函数。这两个操作的实现方式与上面两个操作类似，只是在其中不比较元素，而是检查条件是否成立。
   7. 最后几个操作都需要检查表元素的内容，属于基本内容的检索。数据存储和检索是一切计算和信息处理的基础，后面有关字典和检索的一张将深入研究这个问题。
3. 变动操作：加入元素
   1. 下面考虑表的变动操作，即各种加入和删除元素的操作。其中在表的尾端加入和和三处操作实现很简单，在其他位置加入和删除的操作麻烦一些。
   2. 加入元素是的各种情况，假定在前面图所示的连续表状态下，以集中不同的方式加入一个新元素。
   3. 尾端加入新数据项：这种情况要求把新数据项存入当时表中的第一个空位，及下标num的位置。如果这是num=max，级元素个数等于容量，表满了，操作就操作失败。如果表不满就直接存入元素，并更新表的元素计数值。显然，这是一个O（1）操作。如果希望把元素简单的加入表中，没有其他要求，就应该采用尾端加入的方式，因为这样操作最简单，效率最高。
   4. 新数据存入元素存储区的第i个单元：这是一般情况，尾端加入是这里的特殊情况，即其中的i恰好等于num；首段加入也是它的特殊情况。在一般情况下，需要首先检查下标i是否为插入元素的合法位置。确定合法后就可以插入了。通常情况下位置i已经有数据，要把新数据存入这里，又不能简单的抛弃原有数据，就必须把该项数据移走。移动数据的方式需要根据操作的要求确定。此外，操作前也要检查表是否已满，操作结束后的状态还应该保持有数据的单元在存储前段连续，以及num的正确更新
   5. 如果操作不要求维持原有元素的相对位置，可以采用简单处理方式：把原来位置i的元素移动位置num，放到其他以后元素之后，腾出位置i放入新元素，最后把元素计数值num加1。这一操作人能在O（1）时间完成。
   6. 如果要求保持原有的元素的舒徐，就不能像上面那样简单的腾出空位，必须把插入的位置i之后的元素逐一下移，最后把数据项存入位置i。这样操作的开销与移动元素的个数成正比，一般而言受限于表中元素个数，最坏和平均情况都是O(n)。
### 顺序表的结构
   1. 从前面的讨论中已经看到，一个顺序表的完整信息包括两个部分，一部分是表中的元素集合，另一部分是为实现正确的操作而需记录的信息，及那些有关表的整体情况的信息。根据前面的考虑，后一部分信息中包括怨怒是存储区的容量和当前表中的元素个数两项。一个具体数据结构应该具有一个对象的整体形态。对于顺序表，就是要把上述两块信息关联起来，形成一个完整的对象。怎样把这两部分信息组织为一个顺序表的实际表示呢？这是实现顺序表时需要解决的第一个问题。

### python 的 list 实现
1. 前面介绍了顺序表的各方面情况和实现技术。由于本书使用python，这里不准备给出在python里定义顺序表的实际代码，因为python的list和tuple就采用了顺序表的实现技术。
2. python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，在各种操作中维持已有元素的顺序。其重要的实现约束还有：
   1. 基于下标的高效元素访问和更新，时间复杂度应该是O(1).
   2. 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识不变。
3. 这基本约束决定了list的可能解决方案：
   1. 由于要求O(1)时间的元素访问，并能维持元素的顺序，这种表只能采用连续表技术，表中元素保存在一块连续存储区里
   2. 要求能够容纳任意多的元素，就必须能更换元素存储区。要想在更换存储区时list对象的标识不变，只能采用分离实现技术。
4. 在python的官方实现中，list就是一种采用分离技术实现的动态顺序表，其性质都源于这种实现方式。Python的list采用了前面介绍了元素存储区调整策略，如果需要反复加入元素，用list.append()
5. 在python的官方系统中，list实现采用了如的实际策略：在建立空表时，系统分配一块能容纳8元素的存储区；在执行插入操作时，如果元素区满就换一块4倍大的存储区。但如果当时的表已经很大，系统将改变策略，换存储区时容量加倍。这里的“很大”是一个实现确定的参数，目前的值是5000。引入后一个策略是为了避免出现过多空闲的存储位置。如前所述，通过这套技术实现的list，尾端加入元素操作的平均时间复杂度是O(1).
### list 主要操作性质
1. lsit结构的其他特点也由其顺序表实现方式决定。例如，由于其中一般位置的插入和删除操作都是保序的，要移动一些表元素，因此需要O(n)时间。在其他位置加入元素时也要检查存储区是否已满，如果满了就需要换一块内存，把原有元素复制过去。这些操作可以优化，例如在复制元素的过程中完成新元素加入。
2. 再看看其他操作的情况。对那些所有序列都有共性操作，复杂度有操作中需要考察的元素个数确定。
   1. 元素访问和赋值，尾端加入和尾端删除都是O(1)操作。
   2. 一般位置的元素加入，切片替换，切片删除，表拼接等都是O(n)操作。pop操作默认删除尾部元素，时间复杂度为O(1)
3. python 的一个问题是没有提供检查一个list对象的当前存储块容量的操作，也没有设置容量的操作，一切与容量有关的处理都由python解释器自动完成。这样做的优点是降低编程负担，避免认为操作可能引进的错误。但这种设计也限制了表的使用方式，前面提出的策略在这里也难以使用了。
4. list几个特殊操作：
   1. lst.clear()清除表lst所有的元素，这应该是一个O(1)操作，但具体实现的情况见说明。有两种明显的可行做法：
      1. 简单的将lst的元素计数值设置为0，这样元素存储区里的所有元素都看不见了，自然应该看作空表。
      2. 另行分配一个空表用的存储区，原存储区直接丢弃。python解释器的存储管理将自动回收这个存储块
5. 第一种实现最简单，操作效率搞，但不能真正的释放元素存储区占用的存储。如果在执行clear之前这个表很长，执行操作后表里已经没有元素了，但仍占用原有的大块存储。第二种实现是再次从空表开始，如果这个表在增长到很大，过程中又要一次次更换存储区。
6. 语句lst.reverse()修改lst自身，将其元素顺序导致，原来的首元素变成尾元素，其他元素的情况类似。很容易做出下面的实现，显然这个操作的复杂度是O(n)。
### 顺序表的简单总结
1. 顺序结构是组织一组元素的最重要方式。在顺序表结构中，直接采用顺序结构实现线性表，这种结构也许是许多其他数据结构的实现基础。在后面章节里将会反复看到这方面的实例。
2. 采用顺序表结构实现线性表：
   1. 最重要特点是O(1)时间的定位元素访问。很多简单操作的效率也比较高。
   2. 麻烦的是加入/删除等操作效率问题。这类操作改变表中元素序列的结构，是典型的变动操作。由于元素在顺序表的存储区里连续排列，加入、删除操作有可能要移动很多元素，操作代价高。
   3. 只有特殊的尾端插入、删除操作具有O（1）时间复杂度。但插入操作复杂度还受到元素存储区固定大小的限制。通过适当的存储区扩充策略，一系列尾端插入可以达到O（1）的平均复杂度。
3. 顺序表的优点和缺点在于其元素存储的集中方式和连续性。从缺点看，这样的表结构不够灵活，不容易调整和变化。如果在一个表的使用中需要经常修改结构，用顺序表去实现就不太方便，反复操作的代价可能很高。
4. 还有一个问题也值得提出：如果程序里需要巨大的线性表，采用顺序表实现就需要巨大的快的连续存储空间，这也可能造成存储管理方面的困难。